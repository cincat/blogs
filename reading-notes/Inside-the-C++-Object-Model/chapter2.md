# 第二章

## `Default Constructor`的构造操作

新手一般有两个常见的误解：

1. 任何`class`如果没有定义`default constructor`， 就会被合成一个出来。
2. 编译器合成出来的`default constructor`会显式设定"`class`内每个`data member`的默认值"。

正如你所见， 没有一个是真的！

### `Default Constructor`被合成的四个条件

---

#### 成员变量是有默认构造函数的类的实例

```C++
class Foo {public: Foo(); Foo(int) ...}//原文此处有误
class Bar {public: Foo foo; char *str}

void foo_bar() {
    Bar bar;
    if (bar.str) {} ...
}
```

`Bar`的构造函数在编译器拓展之后可能会是下面的这样：

```C++
Bar::Bar() {
    foo.Foo::Foo();
}
```

编译器不会将`str`清零， 这是程序员的责任。

---

#### 有默认构造函数的基类

如果没有任何一个`constructor`继承自一个有默认构造函数的基类， 那么这个类的默认构造函数就会被合成出来， 并且会调用基类的默认构造函数。

如果设计者提供多个构造函数， 但其中都没有默认的构造函数， 编译器就会扩张现在的每一个构造函数， 将调用基类默认构造函数的代码加进去， 如果这个类还有成员函数是类类型， 并且拥有默认的构造函数， 那么在上面的拓展 ***完成之后*** ， 调用这些成员默认构造函数的代码也会加到所有这些构造函数里面。

---

#### 有虚函数的类

编译器会做如下两个扩展：

1. 产生虚函数表
2. 在每个类的实例中产生一个指向虚函数表的指针

---

#### 有虚基类的类

```C++
class X {public: int i;};
class A : public virtual X {public: int j;};
class B : public virtual X {public: double d;};
class C : public A, public B {public: int k;};

void foo(const A *pa) {pa->i = 1024;}

int main() {
    foo(new A);
    foo(new C);
    return 0;
}
```

成员变量`i`在类`A`和`C`中的实际偏移位置不同， 为了能正常调用必须在构造函数中拓展添加确定`i`的偏移位置的代码， 比如说加入一个指向基类的指针：

```C++
void foo(const A *pa) {pa->__vbcX->i = 1024};
```

`vbcX`这个指针毫无疑问就是在类构造的时候添加的。

---

## 拷贝构造函数的构造过程

拷贝构造函数当显式的拷贝构造， 或者函数调用传参以及函数返回的时候就有可能调用，需要注意的是， 拷贝构造函数的可以多参数形式， 只要第二个以及其后的参数都有默认值。  

当类不具备按位拷贝的语义时默认的复制构造函数才会被合成出来， 当前一个小节列出的四种情况出现是可以视为这个类不具备按位拷贝的语义， 他们分别是：

1. 类中的成员变量是其他类， 而且这个类有默认的拷贝构造函数
2. 类继承自一个基类， 这个基类有默认的拷贝构造函数
3. 该类声明了一个或多个虚函数
4. 该类继承自一个虚基类

前两个条件比较好理解， 后面的两个条件都在将一个派生类赋值给一个基类的时候发生， 第三种情况下被赋值的实例需要调整虚函数表的指针， 因为派生类可能本身包含额外的虚函数， 导致虚函数表与父类不同。第四种情况下， 如果派生类赋值给父类， 父类实例需要安插一些代码以设定虚基类指针或者偏移量。

---

## `Named Return Value`

即使拷贝函数有副作用的时候， 下面的优化也会进行。

```Cpp
X bar() {
    X xx;
    // 处理 xx
    return xx;
}

编译器把xx以__result取代：

X x_result;
void bar(X &__result) {
    __result.X::X();
    // 直接处理__result
    return ;
}
```