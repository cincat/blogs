# 第三章

## 数据成员的绑定

早期C++有两种防御性的设计风格

1. 所有的数据成员都放在类声明的开头处
2. 所有的内联函数， 不管大小都放在类声明之外

这样做的目的是为了让函数绑定正确的数据成员，但是随着C++标准的演化， 这两种防御性设计风格都已经不是必要的了，因为标准规定， 一个内联函数实体， 在整个类声明完全看见之前， 是不会被评估求值的。一个例外是成员函数的参数列表在第一次碰到的时候就会被解析，所以需要一种防御性的设计风格， 将类型别名始终放在类声明的开始处。

---

## 数据成员的存取

```cpp
origin.x = 0.0;
pt->x = 0.0;
```

试问， 这两种存取数据成员的方法上有什么差异？  
答案是： 当`Point3d`是一个派生类， 其继承结构中有一个虚基类， 并且存取的数据成员（这里的`x`）是从该虚基类继承而来的时候就会有重大差异。 这时候我们不能说`pt`必然指向哪一种类， 因此在编译期我们就不知道这个成员的偏移量， 所以这个操作必须延迟到执行期， 经由一个额外的间接引导， 才能解决。这体现了指针在C++语言中的动态性。

---

## 继承与数据成员

C++语言保证：出现在派生类中的基类有其完整原样性。

### 虚拟继承

类如果包含一个或者多个虚基类， 将被分割成两部分， 一个不变区域和一个共享区域。不变区域中的数据，不管后继如何变化， 总是拥有固定的偏移量， 所以这部分数据可以被直接存取。 至于共享区域， 所表现的就是虚基类， 这一部分数据，其位置会因为每次的派生操作而变化， 所以他们只可以被间接存取， 在上一个小节中分析两种存取方式效率的时候已经有提到， 最常见的实现共享区域的手段是虚基类指针， 一般与虚函数表放在一起， 在该表中虚函数用正值索引得到， 虚基类指针用负值索引得到。

---

## 指向数据成员的指针

指向数据成员的指针一般而言是一个整型数， 代表该成员的偏移量。 早期版本的编译器有给实际偏移量加一再赋值给指针的操作， 这样做为了空出0，来表示什么指向数据成员的空指针。