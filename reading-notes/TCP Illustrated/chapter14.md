# 第十四章 超时与重传

## 14.3 设置超时重传

TCP时钟为某个变量，该变量值随系统时钟做出更新，但并非一对一同步更新。

### 14.3.2.3 重传二义性和Karn算法

如果一个数据包在传输中超时，该数据包就会重传，接着收到一个确认消息，那么该信息是对第一次还是第二次传输的确认就存在二义性，这就是重传二义性的例子。

Karn算法包括两部分，第一部分：当接收到重传数据的确认信息时不更新RTT估计值；第二部分：TCP在计算RTO的过程中采用一个退避系数，每当重传计时器出现超时的时候，退避系数加倍，该过程一直持续到接收到非重传数据，此时，退避系数重新设置为1.

### 14.3.2.4 带时间戳选项的RTT测量

1. TCP发送端在其发送的每个报文段的TSOPT的TSV中携带一个32比特的时间戳值。
2. 接受端记录上一次成功发送ACK报文的ACK号（LastACK）
3. 当一个新的报文到达的时候，如果其序列号与LastACK的值吻合，则将其TSV存入TsRecent。
4. 接收端发送的任何一个ACK都包含TSOPT，TsRecent变量包含的时间戳值被写入TSER部分。
5. 发送端接受到ACK后，将当前的时钟减去TSER值，得到的新的差值为新RTT样本

### 14.3.5 RTTM对丢包和失序的鲁棒性

- 失序报文段：如果出现失序情况，回复的ACK的TSER部分包含的TSV值为最近接收端收到的有序报文段的时刻，这会使得发送端的RTT样本增大，由此导致新的RTO增大。
- 成功重传： 接受到缓存中缺失的报文段时，窗口会前移，此时对应的ACK的TSV来自最新值，这是比较有利的。

## 14.5 快速重传

TCP在至少观察到dupthreth(3)个重复的ACK后，即重传可能丢失的数据分组，而不必等待重传计时器超时，当然也可以发送新的数据。

## 14.6 带选择确认的重传

## 14.7 伪超时与重传

### 14.7.1 重复SACK扩展

### 14.7.2 Eifel检测算法

利用Eifel检测算法，能够比仅采用DSACK更早检测到伪重传行为，因为他判断伪重传的ACK是在启动丢失恢复之前生成的，相反DSACK只有在重复报文段到达接受段之后才能发送

内容： 使用TCP的时间戳选项，当发送一个重传后，保存其TSV值，当接收到相应分组的ACK后，检查该ACK的TSER部分，如果TSER小于之前存储的TSV值，则可判定该ACK对应的是原始的传输分组，即该重传是伪重传

### 14.7.3 前移RTO恢复

在超时重传后接受到第一个ACK时，TCP会发送新的（非重传）数据，之后再响应后一个到达的ACK，如果其中有一个为重复的ACK，则认为此次重传没有问题，如果这两个都不是重复ACK，则表明该重传是伪重传。

## 14.8 包失序与包重复

如果失序发生在反向链路（ACK），会使得TCP发送窗口快速前移，这种情况可能会导致发送端出现不必要的流量突发，影响可用的网络宽带。

多次重复可能会导致接收端生成一系列重复的ACK，足以触发快速重传。