# 第五章

## 5.10 wait和waitpid函数

waitpid可以指定为非阻塞的，所以在SIGCHLD信号的处理函数中可以循环调用，回收子进程的资源，直到调用失败为止。

## ５.11 accept返回前连接中止

三路握手完成从而连接建立之后，客户端TCP却发来了一个RST，在服务器看来，就在该连接已经由TCP排队，等着服务器进程调用accept的时候RST到达。稍后，服务器调用accept。POSIX指出这种情况下返回的errno值必须是ECONNABORTED，服务器可以忽略这个错误，并再次调用accept。

## ５.12 服务进程中止

## 5.13 SIGPIPE信号

当一个进程向某个已接受到RST的套接字执行写操作时，内核向该进程发送一个SIGPIPE信号，该信号的默认行为是中止进程，因此进程必须捕获它以免不情愿地被终止，无论该进程是捕获了该信号并从处理信号返回，还是简单地忽略该信号，写操作都返回EPIPE错误。

第一次写引发RST，第二次写引发SIGPIPI信号。

## 5.14服务器主机崩溃

1. 当服务主机奔溃时，已有的网络连接上不发出任何东西。
2. 当我们在酷虎上键一行文本，它由writen写入内核，再由客户TCP作为一个数据分节送出，客户随后阻塞于readline调用，等待回射应答
3. 客户TCP持续重传数据分节，试图从服务器上接受一个ACK，当客户TCP最后放弃时，给客户进程返回一个错误，既然客户阻塞在readline调用上，该调用将返回一个错误，如果超时未应答，那么返回的错误应该是ETIMEOUT，如果由中间的某个路由器判定服务器不可达，那么返回的错误就EHOSTUNREACH或者ENETUNREACH。

## 5.15服务器主机奔溃后重启

1. 启动服务器和客户端，并在客户端键入一行文本以确认连接已建立
2. 服务主机奔溃并重启
3. 客户端键入一行文本，他将作为一个TCP数据分节发送到服务器主机
4. 服务主机奔溃后重启，他的TCP丢失了奔溃前的所有连接信息，因此服务器TCP对于收到的来自客户的数据分节响应一个RST
5. 当客户TCP收到该RST时，客户正阻塞于readline调用，导致该调用返回ECONNRESET错误

## 5.16服务器主机关机

Unix系统关机时，init进程通常先给所有的进程发送SIGTERM信号，等待一段固定的时间，然后给所有仍在运行的进程发送SIGKILL信号，如果我们不捕获SIGTERM信号，那么我们的信号将由SIGKILL信号终止，当服务子进程终止时，他所有打开的文件描述符都将被关闭。