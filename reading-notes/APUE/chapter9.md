# 第九章

## 9.4 进程组

同一进程组的进程接受来自同一终端的各种信号，进程组组长可以创建一个进程组，创建该组中的进程，然后终止，只要某个进程组中有一个进程存在，该进程组就存在，这与其组长进程是否终止无关

```cpp
#include <unistd.h>
int setpgid(pid_t pid, pid_t pgid);
```

`setpgid`函数将pid进程的进程组ID设置为`pgid`,如果这两个参数相等，那么由pid指定的进程成为进程组组长，如果pid是0，则使用调用者的进程ID，如果pgid为0，则由pid指定的进程成为进程组组长

## 9.5 会话

```cpp
#include <unistd.h>

pid_t setsid(void);
```

如果调用该函数的进程不是一个进程组的组长，则次函数创建一个新的会话，具体会发生以下三件事：

1. 该进程会变成新会话的会话首进程，此时该进程是新会话中的唯一进程
2. 该进程成为一个新进程组的组长进程，新进程组ID就是该调用进程的进程ID
3. 该进程没有控制终端，如果在调用`setsid`之前该进程有一个控制终端，那么这种联系也被切断

## 9.6 控制终端

+ 一个会话可以有一个控制终端
+ 建立与控制终端连接的会话首进程称为控制进程
+ 一个会话中的几个进程组可以被分为一个前台进程组以及一个或多个后台进程组
+ 如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组
+ 无论何时键入终端的退出键（通常是ctrl+\）,都会将退出信号发送到前台进程组的所有进程
+ 无论何时键入终端的中断键（通常是Ctrl+C）,都会将退出信号发送至前台进程组的所有进程
+ 如果终端接口检测到调制解调器已经断开连接，则将挂断信号发送至控制进程

## 9.8 作业控制

允许一个终端上启动多个作业（进程组），它控制哪个作业可以访问该终端以及哪些作业在后台运行。

## 9.10 孤儿进程组

该组中的每一个成员的父进程要么是该组的一个成员，要么不是改组所属会话的成员；等价的定义是如果一个进程组不是孤儿进程组的条件是——该组中有一个进程，其父进程在属于同一会话的另一组中。

POSIX.1要求向新孤儿进程组中处于停止状态的每一个进程发送挂断信号(SIGHUP)，接着向其发送继续信号(SIGCONT)。

如果孤儿进程在停止后继续运行的过程中试图读标准输入，对该后台进程组产生SIGTTIN，但在这里，这是一个孤儿进程组，如果内核用此信号停止它，则此进程组中的进程就不会继续，因此POSIX.1规定，read返回出错，其errno值设为EIO。

最后需要注意的是，父进程终止时，子进程编程后台进程组，因为父进程是有shell作为前台作业执行的。